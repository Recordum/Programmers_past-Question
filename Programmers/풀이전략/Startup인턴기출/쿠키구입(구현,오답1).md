## 쿠키구입(구현,오답1)

>__<문제 설명>__   
> 과자를 바구니 단위로 파는 가게가 있습니다. 이 가게는 1번부터 N번까지 차례로 번호가 붙은 바구니 N개가 일렬로 나열해 놨습니다.
철수는 두 아들에게 줄 과자를 사려합니다. 첫째 아들에게는 l번 바구니부터 m번 바구니까지, 둘째 아들에게는 m+1번 바구니부터 r번 바구니까지를 주려합니다. 단, 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N). 즉, A[i] 를 i번 바구니에 들어있는 과자 수라고 했을 때, A[l]+..+A[m] = A[m+1]+..+A[r] 를 만족해야 합니다.
각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때, 조건에 맞게 과자를 살 경우 한 명의 아들에게 줄 수 있는 가장 많은 과자 수를 return 하는 solution 함수를 완성해주세요. (단, 조건에 맞게 과자를 구매할 수 없다면 0을 return 합니다)


>__<제한 사항>__   
> * cookie의 길이는 1 이상 2,000 이하입니다.   
> * cookie의 각각의 원소는 1 이상 500 이하인 자연수입니다.
> 


### 문제접근

처음에는 DP문제를 분할정복으로 해결 하는 문제로 생각했으나, 해결방법이 안떠올라 단순 구현 풀이로 접근했다.
   
* 쿠기 갯수 총합이 2로 나누어떨어질때 까지 시작점 or 끝점에서 하나씩 제거하는 알고리즘으로 구현하려했으나. 쿠키 갯수가 배열에 균일하게 분포한지 않기때문에 실패했다.
* 푸는데 실패하여 풀이를 검색하였다. 풀이를 보며 다시 문제를 풀었다. ->  [문제풀이](https://velog.io/@ajufresh/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%BF%A0%ED%82%A4%EA%B5%AC%EC%9E%85-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-Java)
* 풀이 핵심은 배열에서 반으로 나누어지는 지점을 임의로 고른후, 왼쪾 사이드와 오른쪽 사이드 균형이 맞을떄가지 반복한다.
* for문으로 임의외 지점을 모두 탐색하고 그안에 while문으로 나누어진 왼쪽과 오른쪽 사이드 균형을 맞추며 더한다.

PS를 진행하며 for문안에 while문을 사용해본적이 없는데, 좋은 패턴을 알게 된거 같다.